import 'dart:math';
import 'dart:async';
import 'package:flutter/material.dart';

enum GameMode { untimed, timed }
enum PuzzleOperation { addition, subtraction }

class GameController extends ChangeNotifier {
  int gridSize;
  GameMode _mode = GameMode.untimed;
  PuzzleOperation operation = PuzzleOperation.addition;
  late List<List<int?>> grid;
  late List<List<int?>> _solutionGrid;
  late List<List<bool>> isFixed;
  late List<List<bool>> isWrong;
  late List<List<bool>> isHinted; // NEW: Track which cells were revealed by hints
  int score = 0;
  Duration timeLeft = const Duration(minutes: 5);
  Timer? _timer;
  bool isPlaying = false;
  int seedNumbers = 0;
  bool _timerStarted = false;

  // NEW: Hints system
  int maxHints = 2; // Maximum hints allowed per game
  int hintsUsed = 0; // Track how many hints have been used
  int hintPenalty = 5; // Points deducted per hint

  // NEW: Game metrics for backend
  DateTime? _gameStartTime;
  int? _completionTimeSeconds;
  int _correctAnswers = 0;
  int _totalPlayerCells = 0;
  double _accuracyPercentage = 0.0;

  List<List<int?>> get solutionGrid => _solutionGrid;
  int get hintsRemaining => maxHints - hintsUsed;

  GameController({this.gridSize = 4}) {
    _initGrid();
  }

  void setOperation(PuzzleOperation newOperation) {
    if (operation == newOperation) return;
    operation = newOperation;
    resetGame();
  }

  void _initGrid() {
    final random = Random();
    grid = List.generate(gridSize, (_) => List.filled(gridSize, null));
    _solutionGrid = List.generate(gridSize, (_) => List.filled(gridSize, null));
    isFixed = List.generate(gridSize, (_) => List.filled(gridSize, false));
    isWrong = List.generate(gridSize, (_) => List.filled(gridSize, false));
    isHinted = List.generate(gridSize, (_) => List.filled(gridSize, false)); // NEW

    grid[0][0] = -1;
    _solutionGrid[0][0] = -1;
    isFixed[0][0] = true;

    _createBoard(random);
    isPlaying = true;
    notifyListeners();
  }

  void _createBoard(Random random) {
    List<int> availableRows = [];
    List<int> availableCols = [];

    for (int i = 0; i < gridSize; i++) {
      availableRows.add(i);
      availableCols.add(i);
    }

    seedNumbers = 0;

    try {
      for (int i = 0; i < 4; i++) {
        int randomRow, randomCol;

        do {
          if (seedNumbers == 0) {
            randomRow = 0;
            randomCol = availableCols[random.nextInt(availableCols.length - 1) + 1];
          } else {
            randomRow = availableRows[random.nextInt(availableRows.length)];
            randomCol = availableCols[random.nextInt(availableCols.length)];
          }
        } while (randomRow == 0 && randomCol == 0);

        _solutionGrid[randomRow][randomCol] = _randomNumberNotInRowCol(randomRow, randomCol, random);
        grid[randomRow][randomCol] = _solutionGrid[randomRow][randomCol];
        isFixed[randomRow][randomCol] = true;

        seedNumbers++;
        availableRows.remove(randomRow);
        availableCols.remove(randomCol);
      }

      if (operation == PuzzleOperation.addition) {
        _solvingBoard1();
      } else {
        _solvingBoard1Subtraction();
      }

      _addAdditionalSeeds(random);

      for (int n = 0; n < 20; n++) {
        if (operation == PuzzleOperation.addition) {
          _solvingBoard();
        } else {
          _solvingBoardSubtraction();
        }
      }

      if (!_checkBoardSolvable()) {
        _prepareGameBoard();
      } else {
        debugPrint("Board not solvable, regenerating...");
        _clearBoard();
        _createBoard(random);
      }
    } catch (e) {
      debugPrint("Error in board creation: $e");
      _clearBoard();
      _createBoard(random);
    }
  }

  int _randomNumberNotInRowCol(int row, int col, Random random) {
    int number;
    do {
      number = random.nextInt(25) + 1;
    } while (_isNumberUsedInRowOrColumn(number, row, col));
    return number;
  }

  bool _isNumberUsedInRowOrColumn(int number, int row, int col) {
    for (int i = 0; i < gridSize; i++) {
      if (_solutionGrid[row][i] == number || _solutionGrid[i][col] == number) {
        return true;
      }
    }
    return false;
  }

  void _solvingBoard1() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) {
          continue;
        } else if (i == 0 && (j >= 1 && j < gridSize)) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[n][i] != null && _solutionGrid[n][j] != null) {
                _solutionGrid[i][j] = _solutionGrid[n][i]! + _solutionGrid[n][j]!;
                break;
              }
            }
          }
        } else if ((i >= 1 && i < gridSize) && j == 0) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[j][n] != null && _solutionGrid[i][n] != null) {
                _solutionGrid[i][j] = _solutionGrid[j][n]! + _solutionGrid[i][n]!;
                break;
              }
            }
          }
        } else {
          if (_solutionGrid[i][j] == null) {
            if (_solutionGrid[i][0] != null && _solutionGrid[0][j] != null) {
              _solutionGrid[i][j] = _solutionGrid[i][0]! + _solutionGrid[0][j]!;
            }
          }
        }
      }
    }
  }

  void _solvingBoard() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) {
          continue;
        } else if (i == 0 && (j >= 1 && j < gridSize)) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[n][i] != null && _solutionGrid[n][j] != null) {
                _solutionGrid[i][j] = _solutionGrid[n][i]! + _solutionGrid[n][j]!;
                break;
              }
            }
          }
        } else if ((i >= 1 && i < gridSize) && j == 0) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[i][n] != null && _solutionGrid[j][n] != null) {
                _solutionGrid[i][j] = _solutionGrid[j][n]! + _solutionGrid[i][n]!;
                break;
              }
            }
          }
        } else {
          if (_solutionGrid[i][j] == null) {
            if (_solutionGrid[i][0] != null && _solutionGrid[0][j] != null) {
              _solutionGrid[i][j] = _solutionGrid[i][0]! + _solutionGrid[0][j]!;
            }
          }
        }
      }
    }
  }

  void _solvingBoard1Subtraction() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) {
          continue;
        } else if (i == 0 && (j >= 1 && j < gridSize)) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[n][i] != null && _solutionGrid[n][j] != null) {
                _solutionGrid[i][j] = (_solutionGrid[n][i]! - _solutionGrid[n][j]!).abs();
                break;
              }
            }
          }
        } else if ((i >= 1 && i < gridSize) && j == 0) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[j][n] != null && _solutionGrid[i][n] != null) {
                _solutionGrid[i][j] = (_solutionGrid[j][n]! - _solutionGrid[i][n]!).abs();
                break;
              }
            }
          }
        } else {
          if (_solutionGrid[i][j] == null) {
            if (_solutionGrid[i][0] != null && _solutionGrid[0][j] != null) {
              _solutionGrid[i][j] = (_solutionGrid[i][0]! - _solutionGrid[0][j]!).abs();
            }
          }
        }
      }
    }
  }

  void _solvingBoardSubtraction() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) {
          continue;
        } else if (i == 0 && (j >= 1 && j < gridSize)) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[n][i] != null && _solutionGrid[n][j] != null) {
                _solutionGrid[i][j] = (_solutionGrid[n][i]! - _solutionGrid[n][j]!).abs();
                break;
              }
            }
          }
        } else if ((i >= 1 && i < gridSize) && j == 0) {
          if (_solutionGrid[i][j] == null) {
            for (int n = 1; n < gridSize; n++) {
              if (_solutionGrid[i][n] != null && _solutionGrid[j][n] != null) {
                _solutionGrid[i][j] = (_solutionGrid[j][n]! - _solutionGrid[i][n]!).abs();
                break;
              }
            }
          }
        } else {
          if (_solutionGrid[i][j] == null) {
            if (_solutionGrid[i][0] != null && _solutionGrid[0][j] != null) {
              _solutionGrid[i][j] = (_solutionGrid[i][0]! - _solutionGrid[0][j]!).abs();
            }
          }
        }
      }
    }
  }

  void _addAdditionalSeeds(Random random) {
    List<int> availableRows = [];
    List<int> availableCols = [];

    for (int i = 0; i < gridSize; i++) {
      availableRows.add(i);
      availableCols.add(i);
    }

    try {
      while (seedNumbers < 6) {
        int randomRow = availableRows[random.nextInt(availableRows.length)];
        int randomCol = availableCols[random.nextInt(availableCols.length)];

        if ((randomRow != 0 && randomCol != 0) &&
            _solutionGrid[randomRow][randomCol] == null &&
            _checkCondition(randomRow, randomCol)) {

          _solutionGrid[randomRow][randomCol] = random.nextInt(25) + 1;
          grid[randomRow][randomCol] = _solutionGrid[randomRow][randomCol];
          isFixed[randomRow][randomCol] = true;
          seedNumbers++;

          for (int n = 0; n < 20; n++) {
            if (operation == PuzzleOperation.addition) {
              _solvingBoard();
            } else {
              _solvingBoardSubtraction();
            }
          }

          availableRows.remove(randomRow);
          availableCols.remove(randomCol);
        }
      }
    } catch (e) {
      debugPrint("Error adding seeds: $e");
      for (int i = 0; i < gridSize; i++) {
        for (int j = 0; j < gridSize; j++) {
          if (!isFixed[i][j] || seedNumbers > 4) {
            if (isFixed[i][j] && seedNumbers > 4) {
              _solutionGrid[i][j] = null;
              grid[i][j] = null;
              isFixed[i][j] = false;
            }
          }
        }
      }
      seedNumbers = 4;
      _addAdditionalSeeds(random);
    }
  }

  bool _checkCondition(int i, int j) {
    if (i == 0) {
      if (_solutionGrid[i][j] == null) {
        for (int n = 1; n < gridSize; n++) {
          if (_solutionGrid[n][i] == null || _solutionGrid[n][j] == null) {
            return true;
          } else {
            return false;
          }
        }
      }
    } else if (j == 0) {
      if (_solutionGrid[i][j] == null) {
        for (int n = 1; n < gridSize; n++) {
          if (_solutionGrid[n][i] == null || _solutionGrid[n][j] == null) {
            return true;
          } else {
            return false;
          }
        }
      }
    } else {
      if (_solutionGrid[i][j] == null) {
        if (_solutionGrid[i][0] == null || _solutionGrid[0][j] == null) {
          return true;
        } else {
          return false;
        }
      }
    }
    return false;
  }

  bool _checkBoardSolvable() {
    int zeroCount = 0;
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) continue;
        if (_solutionGrid[i][j] == null) {
          zeroCount++;
        }
      }
    }
    return zeroCount > 0;
  }

  void _prepareGameBoard() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (!isFixed[i][j]) {
          grid[i][j] = null;
        }
      }
    }
  }

  void _clearBoard() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        grid[i][j] = null;
        _solutionGrid[i][j] = null;
        isFixed[i][j] = false;
        isWrong[i][j] = false;
        isHinted[i][j] = false; // NEW
      }
    }
    grid[0][0] = -1;
    _solutionGrid[0][0] = -1;
    isFixed[0][0] = true;
    seedNumbers = 0;
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // GAME LOGIC
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  void updateCell(int row, int col, int? value) {
    if (isFixed[row][col] || !isPlaying || (row == 0 && col == 0)) return;
    if (value == null || value < 0) return;
    grid[row][col] = value;
    notifyListeners();
  }

  // NEW: Enhanced hint system
  bool useHint(int row, int col) {
    if (!isPlaying || isFixed[row][col] || (row == 0 && col == 0)) {
      debugPrint("âš ï¸ Cannot use hint on this cell");
      return false;
    }

    if (hintsRemaining <= 0) {
      debugPrint("âš ï¸ No hints remaining");
      return false;
    }

    if (_solutionGrid[row][col] == null) {
      debugPrint("âš ï¸ No solution value for cell [$row][$col]");
      return false;
    }

    // Reveal the correct answer
    grid[row][col] = _solutionGrid[row][col];
    isHinted[row][col] = true;
    hintsUsed++;

    // Deduct points
    score = max(0, score - hintPenalty);

    debugPrint("ðŸ’¡ Hint used at ($row, $col) = ${grid[row][col]}");
    debugPrint("   Hints remaining: $hintsRemaining");
    debugPrint("   Score after penalty: $score");

    notifyListeners();
    return true;
  }

  // REMOVED: Old provideHint method - replaced with useHint

  bool validateGrid() {
    int correctCount = 0;
    int totalCells = (gridSize * gridSize) - 1; // Exclude top-left corner

    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) continue;
        if (grid[i][j] != null && grid[i][j] == _solutionGrid[i][j]) {
          correctCount++;
        }
      }
    }

    // SCORING SYSTEM
    if (correctCount == 0) {
      score = 0;
    } else {
      if (mode == GameMode.untimed) {
        // UNTIMED MODE: Base score from accuracy (0-100)
        double accuracyRatio = correctCount / totalCells;
        int baseScore = (accuracyRatio * 100).round().clamp(0, 100);

        // Deduct hint penalties
        score = max(0, baseScore - (hintsUsed * hintPenalty));
      } else {
        // TIMED MODE: Base score (0-70) + Time bonus (0-30)
        double accuracyRatio = correctCount / totalCells;
        int baseScore = (accuracyRatio * 70).round();

        int timeBonus = 0;
        int remainingSeconds = timeLeft.inSeconds;

        if (remainingSeconds > 240) {
          // > 4 minutes: 30 bonus points
          timeBonus = 30;
        } else if (remainingSeconds > 180) {
          // > 3 minutes: 22.5 bonus points
          timeBonus = 22;
        } else if (remainingSeconds > 120) {
          // > 2 minutes: 15 bonus points
          timeBonus = 15;
        } else if (remainingSeconds > 60) {
          // > 1 minute: 7.5 bonus points
          timeBonus = 7;
        } else if (remainingSeconds > 0) {
          // < 1 minute but still has time: 2.5 bonus points
          timeBonus = 2;
        } else {
          timeBonus = 0;
          score = 0;
          notifyListeners();
          return false;
        }

        int finalScore = baseScore + timeBonus;

        // Deduct hint penalties
        score = max(0, finalScore - (hintsUsed * hintPenalty));
      }
    }

    notifyListeners();

    bool isComplete = correctCount == totalCells;
    if (isComplete) {
      isPlaying = false;
      if (mode == GameMode.timed) {
        stopTimer();
      }
    }

    return isComplete;
  }

  void checkGrid() {
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        isWrong[i][j] = false;
      }
    }

    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) continue;
        if (grid[i][j] != null && grid[i][j] != _solutionGrid[i][j]) {
          isWrong[i][j] = true;
        }
      }
    }

    notifyListeners();
  }

  void solvePuzzle() {
    if (!isPlaying) return;
    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        if (i == 0 && j == 0) continue;
        grid[i][j] = _solutionGrid[i][j];
        isFixed[i][j] = true;
      }
    }

    for (int i = 0; i < gridSize; i++) {
      for (int j = 0; j < gridSize; j++) {
        isWrong[i][j] = false;
      }
    }

    isPlaying = false;
    if (mode == GameMode.timed) {
      stopTimer();
    }
    score = 0; // No points for auto-solve
    notifyListeners();
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // TIMER
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  void startTimer() {
    if (mode != GameMode.timed) return;
    if (_timerStarted) return;

    _timerStarted = true;
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (timeLeft.inSeconds > 0 && isPlaying) {
        timeLeft = timeLeft - const Duration(seconds: 1);
        notifyListeners();

        if (mode == GameMode.timed) {
          validateGrid();
        }
      } else if (timeLeft.inSeconds <= 0) {
        stopTimer();
        isPlaying = false;
        score = 0;
        notifyListeners();
      }
    });
  }

  void stopTimer() {
    _timer?.cancel();
    _timerStarted = false;
  }

  void resetGame() {
    stopTimer();
    score = 0;
    timeLeft = const Duration(minutes: 5);
    _timerStarted = false;
    hintsUsed = 0; // NEW: Reset hints
    _initGrid();
  }

  void changeGridSize(int newSize) {
    gridSize = newSize;
    resetGame();
    notifyListeners();
  }

  GameMode get mode => _mode;

  set mode(GameMode newMode) {
    if (_mode == newMode) return;
    _mode = newMode;
    notifyListeners();
  }

  void toggleMode() {
    if (_mode == GameMode.untimed) {
      mode = GameMode.timed;
    } else {
      mode = GameMode.untimed;
    }
  }

  String getRuleSymbol(int row, int col) {
    if (row == 0 || col == 0) return '';
    return operation == PuzzleOperation.addition ? '+' : '-';
  }

  String getRuleDescription(int row, int col) {
    if (row == 0 || col == 0) return '';
    return operation == PuzzleOperation.addition ? 'A + B = C' : '|A - B| = C';
  }

  @override
  void dispose() {
    stopTimer();
    super.dispose();
  }
}